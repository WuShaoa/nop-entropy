<?xml version="1.0" encoding="UTF-8"?>

<!--
支持异步执行的轻量化任务引擎。持久化状态为可选特性，如果在步骤上配置了saveState，则可以从任意步骤中断并恢复执行。

@firstStep 当graphMode为true时，第一个执行的步骤id
-->
<task defaultSaveState="!boolean=false" version="!long=0"
      restartable="!boolean=true" graphMode="!boolean=false" enterSteps="csv-set" exitSteps="csv-set"
      x:schema="/nop/schema/xdef.xdef" xmlns:x="/nop/schema/xdsl.xdef" xmlns:xdef="/nop/schema/xdef.xdef"
      xdef:name="TaskFlowModel" xdef:bean-package="io.nop.task.model"
      xdef:ref="TaskStepsModel" xdef:model-name-prop="name" xdef:model-version-prop="version"
>
    <!--
    设置task的访问权限
    -->
    <auth xdef:ref="../schema/auth.xdef"/>

    <xdef:define xdef:name="TaskExecutableModel" executor="bean-name" returnType="generic-type"
                 displayName="string" timeout="!long=0" persisVars="csv-set">

        <description xdef:value="string"/>

        <!--
        @persist [是否持久化保存] 标记为persist的变量会自动保存，支持中断后恢复执行
        -->
        <input name="!var-name" displayName="string" xdef:name="TaskInputModel"
               type="generic-type" mandatory="!boolean=false" role="string"
               xdef:unique-attr="name" persist="!boolean=true" fromTaskScope="!boolean=false">
            <description xdef:value="string"/>
            <source xdef:value="xpl"/>
        </input>

        <!--
        @persist 输出变量是否需要被持久化到数据库中。如果不设置持久化，则一旦中断任务则会丢失相应的输出变量
        @toTaskScope 如果为true，则输出变量到整个task共享的scope中，否则输出到parentScope中
        -->
        <output name="!var-name" displayName="string" persist="!boolean=false"
                xdef:name="TaskOutputModel" toTaskScope="!boolean=false" type="generic-type"
                xdef:unique-attr="name" exportAs="var-name" roles="csv-set">
            <description xdef:value="string"/>
            <source xdef:value="xpl"/>
        </output>

        <onReload xdef:value="xpl"/>

        <!--
        对taskStep进行增强，返回新的step

        @order 按照从小到大的顺序排序。order更小的decorator会先被应用
        -->
        <decorator order="!int" name="!string" bean="bean-name"
                   xdef:name="TaskDecoratorModel" xdef:unique-attr="name">
            <source xdef:value="xpl"/>
        </decorator>

        <when xdef:value="xpl-predicate"/>

        <validator xdef:ref="../validator.xdef"/>

        <catch xdef:value="xpl"/>

        <finally xdef:value="xpl"/>

        <!--
          如果发生异常，则重试整个task
        -->
        <retry maxRetryCount="!int=0" retryDelay="!int=0" maxRetryDelay="!int=0"
               exponentialDelay="!boolean=true" xdef:name="TaskRetryModel">
            <!--
              上下文环境中存在$exception变量，返回false表示异常不可被恢复，不能继续重试
            -->
            <exception-filter xdef:value="xpl-predicate"/>
        </retry>

        <!--
         限制对同一个key的调用并发数不能超过指定值
      -->
        <throttle maxConcurrent="!int" maxWait="!int" keyExpr="expr" xdef:name="TaskThrottleModel"/>

        <!--
          限制对同一个key的调用速率不能超过指定值
        -->
        <rate-limit requestPerSecond="!double" maxWait="!int" keyExpr="expr" xdef:name="TaskRateLimitModel"/>


    </xdef:define>

    <!--
    @concurrent 指定本步骤的scope是否需要支持并发访问，如果是，则scope会使用ConcurrentHashMap，否则就使用普通的HashMap
    @extType 用于指定步骤的扩展类型
    @runOnContext 指定本步骤中的操作都使用IContext.runOnContext来执行
    @next 本步骤执行完毕后缺省跳转到的步骤。如果没有指定，则缺省步骤为下一个兄弟节点
    @saveState 是否需要持久化状态用于失败后重新执行本步骤时的状态恢复
    @allowStartIfComplete 如果设置为false, 则重新执行时已经完成的步骤会被跳过
    @nextOnError 如果配置了nextOnError，则当内部抛出异常的时候会被自动包装为ErrorBean对象，并跳转到指定步骤。
    @waitSteps 图模式执行时，需要等待前置步骤执行完毕才能执行本步骤
    -->
    <xdef:define xdef:name="TaskStepModel" xdef:ref="TaskExecutableModel" concurrent="!boolean=false"
                 extType="var-name" tagSet="csv-set" name="var-name"
                 allowStartIfComplete="!boolean=false" internal="!boolean=false" errorName="var-name"
                 runOnContext="!boolean=false" waitSteps="csv-set" ignoreResult="!boolean=false"
                 next="string" nextOnError="string" saveState="boolean">
    </xdef:define>

    <!--

    -->
    <xdef:define xdef:name="TaskStepsModel"
                 xdef:ref="TaskStepModel">
        <steps xdef:body-type="list" xdef:key-attr="name" xdef:bean-child-name="step"
               xdef:bean-body-type="List&lt;io.nop.task.model.TaskStepModel>" xdef:bean-sub-type-prop="type">

            <simple name="!var-name" bean="!bean-name" xdef:ref="TaskStepModel" xdef:name="SimpleTaskStepModel"/>

            <xpl name="!var-name" xdef:ref="TaskStepModel"
                 xdef:name="XplTaskStepModel">
                <source xdef:value="xpl"/>
            </xpl>

            <script name="!var-name" lang="!xml-name" xdef:ref="TaskStepModel"
                    xdef:name="ScriptTaskStepModel">
                <source xdef:value="string"/>
            </script>

            <graph name="!var-name" enterSteps="!csv-set" exitSteps="!csv-set"
                   xdef:ref="TaskStepsModel" xdef:name="GraphTaskStepModel"/>

            <sequential name="!var-name" xdef:ref="TaskStepsModel" xdef:name="SequentialTaskStepModel"/>

            <parallel name="!var-name" xdef:ref="TaskStepsModel" xdef:name="ParallelTaskStepModel"
                      aggregateVarName="var-name"
                      joinType="enum:io.nop.commons.concurrent.AsyncJoinType" autoCancelUnfinished="!boolean=true">
                <aggregator xdef:value="xpl"/>
            </parallel>

            <exit name="!var-name" xdef:ref="TaskStepModel" xdef:name="ExitTaskStepModel">
                <source xdef:value="xpl"/>
            </exit>

            <end name="!var-name" xdef:ref="TaskStepModel" xdef:name="EndTaskStepModel">
                <source xdef:value="xpl"/>
            </end>

            <!--
              延迟执行后续step
            -->
            <delay name="!var-name" delayMillisExpr="!expr" xdef:ref="TaskStepModel" xdef:name="DelayTaskStepModel"/>

            <sleep name="!var-name" sleepMillisExpr="!expr" xdef:ref="TaskStepModel" xdef:name="SleepTaskStepModel"/>

            <fork name="!var-name" varName="!var-name" indexName="var-name" xdef:ref="TaskStepsModel"
                  xdef:name="ForkTaskStepModel"
                  aggregateVarName="var-name"
                  joinType="enum:io.nop.commons.concurrent.AsyncJoinType" autoCancelUnfinished="!boolean=true">
                <producer xdef:value="xpl"/>
                <aggregator xdef:value="xpl"/>
            </fork>

            <fork-n name="!var-name" indexName="var-name" countExpr="!expr" xdef:ref="TaskStepsModel"
                    xdef:name="ForkNTaskStepModel" aggregateVarName="var-name"
                    joinType="enum:io.nop.commons.concurrent.AsyncJoinType" autoCancelUnfinished="!boolean=true">
                <aggregator xdef:value="xpl"/>
            </fork-n>

            <!--
            @returnAs 指定bean方法的返回值所对应的返回变量名，缺省为result。
            -->
            <invoke name="!var-name" bean="!bean-name" method="!var-name" xdef:ref="TaskStepModel" returnAs="var-name"
                    xdef:name="InvokeTaskStepModel">
            </invoke>

            <loop name="!var-name" xdef:ref="TaskStepsModel" xdef:name="LoopTaskStepModel"
                  indexName="var-name" varName="var-name" itemsExpr="!expr" maxCount="!int=0" varType="generic-type">
                <until xdef:value="xpl-predicate"/>
            </loop>

            <loop-n name="!var-name" xdef:ref="TaskStepsModel" varName="var-name" indexName="var-name"
                    xdef:name="LoopNTaskStepModel" beginExpr="!expr" endExpr="!expr" stepExpr="expr">
            </loop-n>

            <choose name="!var-name" xdef:ref="TaskStepModel" xdef:name="ChooseTaskStepModel">
                <decider xdef:value="xpl"/>

                <!--
                可能用于全局跳转，因此不使用嵌套步骤定义
                -->
                <case match="!string" to="var-name" xdef:unique-attr="match"
                      xdef:name="TaskChooseCaseModel" xdef:ref="TaskStepsModel"/>

                <otherwise to="var-name" xdef:ref="TaskStepsModel" xdef:name="TaskChooseOtherwiseModel"/>
            </choose>

            <call-task name="!var-name" taskName="!string" taskVersion="long"
                       xdef:ref="TaskStepModel" xdef:name="CallTaskStepModel"/>

            <!--
            调用task step步骤定义库中的某个指定步骤。步骤定义库的基本结构与task相同，只是没有执行能力
            -->
            <call-step name="!var-name" libName="!string" libVersion="long" stepName="!var-name"
                       xdef:ref="TaskStepModel" xdef:name="CallStepTaskStepModel"/>

            <!--
              挂起当前任务，等待手工触发继续执行
            -->
            <suspend name="!var-name" xdef:ref="TaskStepModel" xdef:name="SuspendTaskStepModel">
                <resume-when xdef:value="xpl-predicate"/>
            </suspend>
        </steps>
    </xdef:define>
</task>