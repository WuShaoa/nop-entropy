# 从零开始编写的下一代逻辑编排引擎

随着低代码概念和产品的流行，很多人都在考虑在自己的项目中引入逻辑编排的概念，将传统上通过手工硬编码生产的逻辑卸载到某个可以灵活配置的逻辑编排引擎上。在本文中，我将介绍一下Nop平台中的逻辑编排引擎TaskFlow的设计思想，分析一下TaskFlow的设计在数学层面的必然性。在文章的最后我会解释一下为什么NopTaskFlow是下一代逻辑编排引擎，这个所谓的下一代具有什么典型特征。

## 一. 逻辑编排到底在编排什么？

当我们使用传统的编程语言和编程框架进行编程时，本质上是在遵循语言所定义的某种约束规范，也可以看作是某种**最佳实践**。但是当我们自己编写一个非常灵活、非常底层的逻辑组织框架时，很容易就打破此前语言内置的形式规范，从而偏离隐含的最佳实践模式。

**可以灵活组织的最小逻辑单元是什么**？传统编程语言的回答现在很标准：函数。那么**函数有什么本质性特征**？

1. 函数具有明确定义的输入和输出

2. 函数可以进行嵌套调用

3. 函数中使用的变量具有复杂的词法作用域

如果更进一步的研究函数的结构，我们还会发现更加复杂的特征，例如

1. 函数参数是传值还是传引用？callByValue? callByRef?callByName?

2. 是否支持函数式参数，也就是所谓的高阶函数？

3. 是否存在独立于返回值的异常处理机制？

4. 是否支持异步返回？

当然，还有最最重要的，**函数不仅仅是认知和组织逻辑的最小单元，还是我们进行抽象的最小单元**。**我们可以复用已有的函数来定义的新的函数**。

那么为什么函数会成为编程语言中最基本的逻辑组织单元，我们现在编写一个逻辑编排引擎的时候还需要基于函数抽象吗？有没有更好的抽象形式？为了搞清楚这个问题，我们有必要懂一点历史。

首先，我们需要清醒的意识到，**计算机编程语言中最初并没有函数概念**，函数概念的建立是一件不平凡的事情。

**早期编程语言（1950s-1960s）**：

- **汇编语言**：在汇编语言中，函数的概念并不明显，程序员通常使用跳转指令来执行代码块。
- **Fortran**：在1955年发布的Fortran语言中，引入了子程序（subroutine）的概念，这可以看作是函数的早期形式。但Fortran中的子程序不支持返回值。

**高级编程语言的兴起（1960s-1970s）**：

- **ALGOL 60**：在1960年发布的ALGOL 60中，引入了现代函数概念，支持返回值，并提出了块结构（局部变量作用域），这是编程语言发展中的一个重要里程碑。
- **Lisp**：在1958年开发的Lisp语言中，函数被视为一等公民，这意味着函数可以作为数据传递、存储和返回，这是函数式编程语言的核心特性。

**结构化编程（1970s）**：

* 结构化编程的概念最早由Edsger W. Dijkstra在1968年的论文[《Go To Statement Considered Harmful》](https://www.dcs.gla.ac.uk/~pat/cpM/choco4/nqueens/Goto-Harmful-Dijkstra.pdf)中提出，他主张通过限制或消除goto语句的使用来改善程序的结构。结构化编程的核心理念是将程序分解为模块化的部分，使用顺序、选择（if-then-else）和循环（while、for）等结构来控制程序的流程。
- **C语言**：1972年发布的C语言，深受Algol 68的影响，其函数定义简洁，支持递归调用，是第一批原生支持结构化编程概念的高级编程语言之一。C语言的流行极大地推动了结构化编程范式的普及。

后续的1980年代是面向对象的天下，函数的地位下降，变得从属于对象，在Java中我们甚至不能在类的外部单独定义函数。而在2000年以后函数式编程逐渐复兴，推动了不可变性和所谓无副作用的纯函数概念的普及。随着多核并行编程、分布式消息系统和大数据处理系统的盛行，函数的概念也在不断地扩展和深化，现代程序语言开始标配async/await机制。可以说，目前所有关于可组合性的研究（如何从小的部分组合得到更大的部分）所得到的最合适的载体就是函数。

NopTaskFlow的设计目标是提供一种**支持差量运算的结构化逻辑分解方案**，贴近编程语言中的函数概念无疑是一种最省心的选择，而且如果未来需要高性能编译执行，也更容易将编排逻辑翻译为普通的函数实现代码。

## 二. 最小逻辑组织单元 TaskStep

迷失在历史中的先贤真言

但是正所谓人类从历史中学到的唯一教训就是人类无法从历史中学到任何教训。二十年就是一代人，下一代人面对新的问题时会忘记前人的智慧，一切仍然从拍脑袋开始。

The unbridled use of the go to statement has an immediate consequence that it becomes terribly hard to find a meaningful set of coordinates in which to describe the process progress.

a programmer independent coordinate system can be maintained to describe the process in a helpful and manageable way.

空间坐标冻结，而时间坐标在流动。
[考不上三本也能给自己心爱的语言加上Coroutine](https://zhuanlan.zhihu.com/p/25964339)

## 三. 比函数更强的是包装后的函数

领域化之后形成稳定的领域坐标系

不是裸函数，而是可以被修饰的富函数(RichFunction)。

## 四. 考不上三本也能实现Coroutine

## 五. 图模式：数据驱动

## 六. TaskFlow与行为树(Behavior Tree)的区别

## 七. TaskFlow与工作流(Workflow)的区别

## 八. 为什么是下一代

说NopTaskFlow是下一代逻辑编排引擎，可能有些人会不服气：我看这个设计平平无奇，都是早已被反复实现过的东西，创新点在哪？别急，这里的下一代指的不是它的功能多，也不是性能高，而是它基于下一代软件构造理论：可逆计算理论所构建，从而呈现出与现有的软件架构设计迥然不同的典型特征。**这些特征是与逻辑编排本身无关的**。这里的逻辑是这样的：

1. 可逆计算是下一代软件构造理论

2. Nop平台是可逆计算指导下从零开始构建的下一代低代码开发平台

3. NopTaskFlow是Nop平台的一个组成部分，它自动继承了这个所谓下一代的特征

这是一件真正有趣的事情。

不是针对单个引擎构建，而是大量引擎共享结构共性。

差量化和元编程

信息最小化表达，描述式结构与运行时结构分离
